#!/usr/bin/env ruby
#
# BioRuby bio-table Plugin BioTable
# Author:: Pjotr Prins
# Copyright:: 2012

rootpath = File.dirname(File.dirname(__FILE__))
$: << File.join(rootpath,'lib')

_VERSION = File.new(File.join(rootpath,'VERSION')).read.chomp

INPUT_ON_STDIN = !$stdin.tty?

$stderr.print "bio-table "+_VERSION+" Copyright (C) 2012 Pjotr Prins <pjotr.prins@thebird.nl>\n\n"

USAGE =<<EOU

bio-table transforms, filters and reorders table files (CSV, tab-delimited).

EOU

if ARGV.size == 0 and not INPUT_ON_STDIN
  print USAGE
end

require 'bio-table'
require 'optparse'
require 'bio-logger'

log = Bio::Log::LoggerPlus.new 'bio-table'
# log.outputters = Bio::Log::Outputter.stderr

Bio::Log::CLI.logger('stderr')
Bio::Log::CLI.trace('info')

options = {show_help: false, write_header: true, skip: 0}
options[:show_help] = true if ARGV.size == 0 and not INPUT_ON_STDIN
opts = OptionParser.new do |o|
  o.banner = "Usage: #{File.basename($0)} [options] filename\n\n"

 
  o.on('--num-filter expression', 'Numeric filtering function') do |par|
    options[:num_filter] = par
  end

  o.on('--rewrite expression', 'Rewrite function') do |par|
    options[:rewrite] = par
  end

  o.on('--columns list', Array, 'List of column names or indices') do |l|
    options[:columns] = l
  end

  o.on('--column-filter expression', 'Column name filtering function') do |par|
    options[:column_filter] = par
  end

  o.on('--merge','Merge tables by rowname') do 
    options[:merge] = true
  end

  o.on('--diff list',Array,'Diff two input files on columns (default rownames)') do |l|
    if l.size==1 and File.exist?(l.first)
      ARGV.unshift l.first
      l = ["0"]
    end
    options[:diff] = l
  end

  o.on('--overlap list',Array,'Find overlap of two input files on columns)') do |l|
    if l.size==1 and File.exist?(l.first)
      ARGV.unshift l.first
      l = ["0"]
    end
    options[:overlap] = l
  end
  
  o.on('--merge','Merge tables by rowname') do 
    options[:merge] = true
  end

  o.separator "\n\tOverrides:\n\n"

  # o.on('--with-header','Include the header element in filtering etc.') do
  #   options[:with_header] = true
  # end

  o.on('--skip lines',Integer,'Skip the first lines before parsing') do |skip|
    options[:skip] = skip
  end

  o.on('--with-rownames','Include the rownames in filtering etc.') do
    options[:with_rownames] = true
  end

  o.separator "\n\tTransform:\n\n"

  o.on('--transform-ids [downcase,upcase]',[:downcase,:upcase],'Transform column and row identifiers') do |par|
    options[:transform_ids] = par.to_sym
  end

  o.separator "\n\tFormat and options:\n\n"
  
  o.on('--in-format [tab,csv]', [:tab, :csv], 'Input format (default tab)') do |par|
    options[:in_format] = par.to_sym
  end

  o.on('--format [tab,csv,rdf]', [:tab, :csv, :rdf], 'Output format (default tab)') do |par|
    options[:format] = par.to_sym
  end

  o.on('--blank-nodes','Output (RDF) blank nodes - allowing for duplicate row names') do 
    options[:blank_nodes] = true
  end

  o.separator "\n\tVerbosity:\n\n"
  
  o.on("--logger filename",String,"Log to file (default stderr)") do | name |
    Bio::Log::CLI.logger(name)
  end

  o.on("--trace options",String,"Set log level (default INFO, see bio-logger)") do | s |
    Bio::Log::CLI.trace(s)
  end
  
  o.on("-q", "--quiet", "Run quietly") do |q|
    Bio::Log::CLI.trace('error')
  end
  
  o.on("-v", "--verbose", "Run verbosely") do |v|
    Bio::Log::CLI.trace('info')
  end
  
  o.on("--debug", "Show debug messages") do |v|
    Bio::Log::CLI.trace('debug')
  end

  o.separator ""

  o.on_tail('-h', '--help', 'Display this help and exit') do
    options[:show_help] = true
  end
end

begin
  opts.parse!(ARGV)

  if options[:show_help] 
    print opts
    print USAGE
  end

  # TODO: your code here
  # use options for your logic
rescue OptionParser::InvalidOption => e
  options[:invalid_argument] = e.message
end

Bio::Log::CLI.configure('bio-table')
logger = Bio::Log::LoggerPlus['bio-table']
logger.info [options, ARGV]

include BioTable

if options[:diff]
  logger.warn "Column settings are ignored for --diff" if options[:columns]
  logger.warn "Ignoring extraneaous files "+ARGV[2..-1].join(",") if ARGV.size>2
  t1 = TableReader::read_file(ARGV[0], options)
  t2 = TableReader::read_file(ARGV[1], options)
  t = Diff::diff_tables(t1,t2, options)
  t.write(options)
  exit
end

if options[:overlap]
  logger.warn "Column settings are ignored for --overlap" if options[:columns]
  logger.warn "Ignoring extraneaous files "+ARGV[2..-1].join(",") if ARGV.size>2
  t1 = TableReader::read_file(ARGV[0], options)
  t2 = TableReader::read_file(ARGV[1], options)
  t = Overlap::overlap_tables(t1,t2, options)
  t.write(options)
  exit
end

if options[:merge]
  ts = []
  ARGV.each do | fn |
    ts << TableReader::read_file(fn, options)
  end
  t = Merge::merge_tables(ts, options)
  t.write(options)
  exit
end

#
# We also support STDIN for the first 'file'. A non-blocking idea can
# be found here:
#
# http://eric.lubow.org/2010/ruby/multiple-input-locations-from-bash-into-ruby/
#

writer = 
  if options[:format] == :rdf
    BioTable::RDF::Writer.new(options[:blank_nodes])
  else
    BioTable::TableWriter::Writer.new(options[:format])
  end

if INPUT_ON_STDIN
  opts = options.dup # so we can modify options
  BioTable::TableLoader.emit(STDIN, opts).each do |row, type| 
    writer.write(TableRow.new(row[0],row[1..-1]),type)
  end
  options[:write_header] = false  # don't write the header for chained files
end

ARGV.each do | fn |
  opts = options.dup # so we can modify options
  f = File.open(fn,"r")
  if not opts[:in_format] and fn =~ /\.csv$/
    logger.debug "Autodetected CSV file"
    opts[:in_format] = :csv
  end
  BioTable::TableLoader.emit(f, opts).each do |row,type| 
    writer.write(TableRow.new(row[0],row[1..-1]),type)
  end
  options[:write_header] = false  # don't write the header for chained files
end
